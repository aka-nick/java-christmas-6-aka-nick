# 개발 문서

## 구현 목록

### 구현 기능 목록

- 달력 초기화 
- 준비된 메뉴 초기화
- 환영멘트를 출력하는 기능
- 예약일자 질문
  - 예약일자 질문멘트 출력하는 기능
  - 예약일자 입력받는 기능
- 주문
  - 주문 멘트 출력하는 기능
  - 주문내용 입력받는 기능
  - 입력받은 전체 주문내용의 각 건을 음식과 수량으로 분리하는 기능
- 주문내역서 출력
  - 주문내역서 시작 안내문구 출력하는 기능
  - 하위의 기능들로 조회된 정보를 출력하는 기능
    - 각 주문(메뉴명, 수량이 포함된) 건을 조회하는 기능
    - 위의 주문 조회 내용을 토대로 총 주문 금액을 계산하는 기능
    - 이벤트 적용 기능
      - 위의 총 주문 금액을 토대로 증정 이벤트 판단하는 기능(증정 상품으로 인한 혜택금액 발생됨)
      - 위의 총 주문 금액을 토대로 각 이벤트의 조건을 판단하여 적용하는 기능(할인으로 인한 혜택금액 발생됨)
    - 위의 이벤트 혜택금액을 토대로 총 혜택 금액을 계산하는 기능
    - 총 주문 금액과 이벤트 혜택금액을 토대로 예상 결제 금액을 계산하는 기능
    - 이벤트 혜택금액을 토대로 증정할 이벤트뱃지 판별하는 기능

### 예외 처리 목록

모든 예외 메시지는 "[ERROR] "로 시작한다 
- [x] 날짜가 숫자가 아닌 경우 (유효하지 않은 날짜입니다. 다시 입력해 주세요.)
- [x] 날짜가 범위를 벗어나는 경우(1 ~ 31) (유효하지 않은 날짜입니다. 다시 입력해 주세요.)
- [x] 없는 메뉴를 선택하는 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)
- [x] 메뉴의 개수가 0개 이하인 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)
- [x] 메뉴 형식이 틀린 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)
- [x] 중복 메뉴를 입력한 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)
- [x] 음료만 주문한 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)
- [x] 주문한 음식의 총합계가 20개를 넘는 경우 (유효하지 않은 주문입니다. 다시 입력해 주세요.)

## 참고할 점

### 용어/개념 설명

- 방문일자(==예약일자) : 12월 1일 ~ 31일 중 하루의 일자. 사용자에게는 일자만 입력받는다. 사실상 방문의 예약을 받는 것이기 때문에 '예약일자'라고도 한다.
- 메뉴 : 카테고리와 음식을 계층적으로 표현한 정적 정보.
- 카테고리 : 메뉴의 하위 목록으로 음식의 그룹을 표현.
- 음식 : 주문될 수 있는 최소의 단위. 이름과 가격을 가지고 있으며, 이름으로 식별됨(같은 이름의 음식은 같은 음식임).
- 주문 : 메뉴 한 건을 실제 음식 n개(수량)로 변환하는 일. 그 과정에서 주문금액이 발생됨.
- 이벤트(==프로모션) : 주문금액의 총합, 각 이벤트의 조건을 따라 할인/증정 혜택이 제공되는 일. 그 과정에서 혜택금액이 발생되고, 각 건을 혜택 내역이라 부름. 'Event'라는 이름으로 만들어진 기존 클래스들이 많아서 프로젝트 상에서는 Promotion 또는 PromotionPlanner(Planner)라는 표현을 사용한다.
- 뱃지 : 혜택금액에 따라 주어지는 리워드 표지.

### 기타 참고 사항

- 고려할 금액의 종류 : 메뉴 금액('증정 메뉴의 가격'도 포함), 총 주문 금액, 할인 금액, 총 혜택 금액, 할인 후 예상 결제 금액
- 이벤트의 종류 : 할인, 증정
  - 할인 이벤트의 종류 : 요일 할인(평일 할인, 주말 할인), 디데이 할인, 특별 할인
  - 증정 이벤트의 종류 : 샴페인 증정
- 뱃지(리워드) 종류 : 5000원 할인(별), 10000원 할인(트리), 20000원 할인(산타)
- 제한조건의 종류 : 총 금액 1만원 미만 할인/증정 미적용, 음료만 주문 불가(예외로 추가), 1회 주문 시 최대 메뉴 개수 20개

- '메뉴'의 구조
  - 메뉴 -1--n< 카테고리 -1--n- 음식(이름/가격)
  - 메뉴는 여러개의 카테고리를 가진다. 각각의 카테고리는 각각의 음식을 가진다. 각각의 음식은 이름과 가격으로 표현된다.
  - 헷갈리는 개념 : 메뉴와 주문 메뉴는 다르다. 메뉴는 '주문 전 메뉴판에 적혀있는 메뉴'고, 주문서에 적힌 주문 메뉴는 '주문한 음식'을 말한다.
- '이벤트' : 1만원 이상일 때 적용되는 할인/증정 혜택.
  - 할인 이벤트
    - 요일 할인 : 평일 할인(일 ~ 목, 각 디저트 메뉴 당 2023원 할인), 주말할인(금/토(1,2, 8,9, 15,16, 22,23, 29,20), 각 메인 메뉴 당 2023원 할인). 적용 기간은 12월 1일부터 31일.
    - 디데이 할인 : 할인액 1000원으로 시작해서 매일 100원씩 증가(총 주문 금액 n원 할인). 적용 기간은 12월 1일부터 25일(주의: 이것만 기간이 다름).
    - 특별 할인 : 달력에 '별'이 있는 날(일/크리스마스 당일, 총 주문 금액 1000원 할인). 적용 기간은 12월 1일부터 31일.
  - 증정 이벤트
    - 음료(샴페인) 증정 : 총 주문 금액 12만원 이상일 때(매일, 25000원 상당의 샴페인 증정(할인 금액으로 산출됨)). 적용 기간은 12월 1일부터 31일까지.

### 체크리스트

#### 제출 관련

- [ ] 비공개 저장소로 만들었는가
- [ ] 저장소명 뒤에 깃허브 아이디를 적었는가
- [ ] 우아한 테크코스 계정을 collaborator로 초대했는가
- [ ] main 브랜치에서 작업하고 있는가

#### 프로젝트 관련

- [ ] 요구사항에 명시된 출력값 형식을 지켰는가
- [ ] Java 17 버전인가? (`java -version`)
- [ ] 테스트에 모두 성공했는가? 성공함을 확인했는가? (`./gradlew clean test`)

#### 코드 관련
- 인덴트는 2까지만 허용한다.
- 3항 연산자, if-else, switch 사용할 수 없다.
- 메서드 최대 길이는 15라인이다.
- 사용자가 잘못된 입력을 할 경우, "[ERROR]"로 시작하는 에러메시지를 출력한 후 그 부분부터 입력을 다시 받는다(Exception으로 잡지 말고 구체적인 예외를 명확하게 잡는다).

## 고민 & 생각 메모

### 2023-11-10 금

- 화폐 객체를 추가하면 화폐금액에 대한 기본적인 처리를 할 수 있을 거라고 나이브하게 생각을 했었다. 그런데 생각해보니 '화폐money'는 음수일 수 없지만 '금액amountOfMoney'은 음수도 가능하다. 당연하다고여겼지만 사실은 애매한 요소가 발견되니 구현이 애매하다.
  - 일단 지금은 음수값도 허용하자. 

### 2023-11-11 토

- 어제의 화폐 객체에 대해서 코딩하다 보니 든 생각. '돈'이라는 것에 대한 공통된 속성만 추상클래스로 정의하고, '화폐'와 '금액'이란 특성에 따른 구체적인 분류는 구체클래스를 만들어 구분하면 어떨까? 그게 좋을 것 같다. 아니면, '화폐'의 확장된 개념이 '금액'이란 개념이라면, 일반적인 상속을 해도 좋을 것 같고 말이다.

### 2023-11-12 일

- 메서드 뿐만 아니라, if/for 등의 블럭 안에서는 하나의 일만 해야한다. 그런 확신이 생겼다.
  - 작성 시 단점: 두 가지 일을 한 번에 작성하는 과정에서 누락할 가능성이 있고, 누락해도 문제가 생기기 전까지 찾기가 어렵다. 따로 따로 작성하면서 코드를 누락하면, 아예 블럭 안의 로직이 비게 되므로 빠뜨릴래야 빠뜨릴 수 없게 된다.
  - 코드 읽을 시 단점: 두 가지 일이 혼합되어 있는 것만으로도 코드를 이해하기 어려워진다.
  - 리팩토링할 시 단점: 두 가지 일을 한 블럭 안에서 해두면, 장차 각각의 일(코드)을 분리하기 어려워진다.
  - 이 정도면 크리티컬한 성능 문제가 있지 않고서는 분리하는게 좋겠다는 판단이 든다.
- 위의 이슈(한 블럭 안에 있는 여러 로직 나누기)를 처리하다가 든 생각
- 기존에는 `-er`, `-or` 객체를 보면 객체들이 가지고 있었어야 할 책임을 받아서 대신 처리하는 클래스(객체가 아닌)이라고 생각했다. 그렇기 때문에 '이런 녀석들의 책임은 적절한 객체로 재분배해야 한다'는 생각을 가지고 있었다.
  - 지금도 객체들이 가지고 있었어야 할 책임을 받아서 대신 처리하는 클래스라는 생각에는 변함이 없다.
  - 하지만, '이런 녀석들의 책임은 적절한 객체로 재분재 해야 한다'는 생각에는 변화가 생겼다. 
  - '이런 녀석들'의 특징은 내부 로직이 매우 절차적이라는 것이다. 여러 객체에서 할 책임을 이 한 곳에서 다루기 때문에 분기문을 타고 조건에 따라 특정 연산을 수행하거나 특정 타입의 결과를 생성하여 리턴하는 특성도 두드러진다.
  - 하지만 '한 곳에서 다루기 때문에' 공통적인 특성을 가진 로직(특정 연산 또는 특정 타입의 결과 생성하여 반환하는 로직)을 한 곳에서 파악하기 좋다는 특징이 있다.
  - 그러므로, 앞으로는 '이런 녀석들' 클래스를 발견하거나 필요하다고 느끼는 순간에 이렇게 판단하면 된다: 객체의 역할을 강화해줄 필요가 있는지, 아니면 코드의 복잡도를 낮출 것인지 트레이드 오프를 잘 고려해서 결정하면 된다.
  - 트레이트 오프 판단에 참고할 힌트 : 현재의 '이런 녀석들'이 다루고 있는 로직(일)이 하나인가? 여러개인가?
    - 하나라면: '이런 녀석'으로 나눠도 좋다. 여러 곳에 나눠진 동일한 일(로직)을 '이런 녀석' 안으로 모아라. 확실한 하나의 일이 확실하게 하나의 관리포인트로 집중되므로, 파악도 쉽고 앞으로 관련 코드를 만지면서도 실수의 여지가 줄을 것이다. 
    - 여러개라면: 이때는 여러개의 '이런 녀석' 클래스를 추출하더라도 큰 실익이 없다. 왜냐면, 여러 일을 각자 하나씩 맡은 여러 클래스가 나올 것이기 때문이다. 즉, '깔끔하게 분리한 로직'이 '여러 클래스로 파편화된다'. 즉, 각각의 일(로직)을 파악하기에는 깔끔한데 여전히 실수의 여지와 전체 로직은 파악하기 어려운 리팩토링 결과가 나오는 것이다.

### 2023-11-14 화

- 입력의 책임은 어디까지일까? 입력을 나누지 않았을 때는 나눠야 할 것 같은 로직이 명확히 보였는데, 모순적이게도 로직을 나누면 나눌 수록 무얼 나눠야 하는 건지 흐릿해진다.

### 2023-11-15 수

- 요구사항을 대충 확인하면 안된다.
  - 사용자에게 안내될 출력메시지만 보고 동작을 추론해서 '당연한 사실'로 알고 있었다.
  - 결과적으로 맞긴 했지만, 요구사항을 확실히 확인하지 않고도 안심하고 있던 스스로에게 놀랐다.
  - 모든 요구사항은 능력껏 확실하게 확인을 하자.
- record에 객체타입 필드를 사용하면, 필드가 불변해도 동등비교 같은 건 할 수 없으니 큰 이점이 사라지는거 아닌가? 라는 의문이 들었다. 값타입을 쉽게 표현하기 위해 많이 쓰는데 동등비교가 불가하다면 그건 값타입의 전제조건을 무너뜨리는 일이기 때문이다.
  - 그런데, record가 자동으로 오버라이드 해주는 equals는 필드 내부의 값까지 비교해주지는 않는다.
    - 예를 들어 List<Integer> 같은 필드를 가지고 있다면, 동등비교가 이뤄지고 있도록 Objects.equals()를 사용해줘야 한다. Objects.equals()는 비교할 타입이 배열이나 객체타입일 경우 재귀적으로 deepEquals()를 실행한다.
    - 만약 Objects.equals()로도 안되면, 당연하게도 직접 내부 비교 로직을 작성해줘야 한다.